# CVE2016-3189

[related Document](https://bugzilla.redhat.com/show_bug.cgi?id=1319648)

## Use After Free (UAF)
UAF occurs at `bzip2recover.c:182`
```c
static void bsPutBit ( BitStream* bs, Int32 bit )
{
   if (bs->buffLive == 8) { // This Point!
      Int32 retVal = putc ( (UChar) bs->buffer, bs->handle );
      if (retVal == EOF) writeError();
      bytesOut++;
      bs->buffLive = 1;
      bs->buffer = bit & 0x1;
   } else {
      bs->buffer = ( (bs->buffer << 1) | (bit & 0x1) );
      bs->buffLive++;
   };
}
```

The crash happens because the end of block 2 is set to be one bit before its start, it tries to write the end stream sequence (sqrt(PI)....), however since it writes its end before the start, no file is opened and this leads to crash.  
The problem is, after closing the output file, block 1 does not set variable "outFile" to NULL. block 2 then checks this variable and because it is not NULL, it tries to write to the output stream, which was closed with bsClose().  

## BUDAlloc
Then, how BUDAlloc DETECTS this error? BUDAlloc generates SEGFAULT when tries to access free'd memory, which is called UAF bug.
bsClose() function frees `BitStream* bs` at the end of function.
This CVE happens because code tries to access bsClose'd data, which is same as free'd bs, BUDAlloc generates SEGFAULT, and bzip2recover treats this signal.  

## ffmalloc
ffmalloc prevents UAF bug by invalidating free'd memory. Therefore, unlike using remained data in bs in glibc, bzip2recover cannot use data in bs in ffmalloc.  
Therefore, ffmalloc PREVENT this bug.