# CVE2018-10685

[related Document](https://github.com/ckolivas/lrzip/issues/95)

## Use After Free (UAF)
UAF occurs at `stream.c:564`
```c
static int lzma_decompress_buf(rzip_control *control, struct uncomp_thread *ucthread)
{
    // ...
	/* With LZMA SDK 4.63 we pass control->lzma_properties
	 * which is needed for proper uncompress */
	lzmaerr = LzmaUncompress(ucthread->s_buf, &dlen, c_buf, &c_len, control->lzma_properties, 5);
	if (unlikely(lzmaerr)) {
		print_err("Failed to decompress buffer - lzmaerr=%d\n", lzmaerr);
		free(ucthread->s_buf);
		ucthread->s_buf = c_buf;
		ret = -1;
		goto out;
	}

	if (unlikely((i64)dlen != ucthread->u_len)) { // This Point!
		print_err("Inconsistent length after decompression. Got %lld bytes, expected %lld\n", (i64)dlen, ucthread->u_len);
		ret = -1;
	}
    // ...
}
```

## BUDALLOC_p, BUDALLOC_d
BUDALLOC_p, BUDALLOC_d randomly cause SEGFAULT or not.

So we marked as `CANNOT_DETERMINE` when it fails to cause SEGFAULT.